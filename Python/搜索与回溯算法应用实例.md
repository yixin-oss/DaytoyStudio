---
title: 搜索与回溯算法应用实例
tags:
- 深度优先搜素
- 广度优先搜索
- Python
categories: 数据结构与算法
mathjax: true
---

## 例1 机器人运动范围

[剑指 Offer 13](https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

```python
地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

示例 1：

输入：m = 2, n = 3, k = 1
输出：3
示例 2：

输入：m = 3, n = 1, k = 0
输出：1

提示：
1 <= n,m <= 100
0 <= k <= 20
```

**准备工作：**数位和增量计算

机器人每次只移动一格，因此每次只需计算$(x-->x+1\quad or \quad x-1)$的数位和增量（仅在1~100适用）.

```python
s_x + 1 if (x + 1) % 10 else s_x - 8
```

<!--more-->

**可达解分析**

根据[数位和]增量公式，每逢进位突变一次，矩阵中满足数位和的解构成的几何形状形如多个等腰直角三角形，每个三角形的直角顶点位于$0,10,20,...$等数位和突变的索引处.

三角形内的解虽然都满足数位和要求，但由于机器人每步只能走一个单元格，而三角形间未必是连同的，因此机器人不一定能到达，称为“**不可达解**”，本题要求“**可达解**”.

- 三角形内部：全部连通；
- 两三角形连通处：若某个三角形内的解是可达解，则必与其左边或上边的三角形连通（即相交），机器人必可从左边或上边走进三角形.

根据上述分析，机器人**仅可通过向右和向下移动**访问所有可达解.

### 法一：深度优先遍历DFS

- **DFS**：暴力法模拟机器人在矩阵中的所有路径，通过递归先朝一个方向搜到底，再回溯到上个节点，沿另一方向搜索，以此类推；
- **剪枝**：在搜索中，遇到数位和超过目标值、此元素已访问的情形则立即返回，称为**可行性剪枝**.

#### 算法流程

- 递归参数：当前元素在矩阵中行列索引$i,j$，两者数位和$si,sj$.
- 终止条件：行列索引越界；数位和超过目标值k; 当前元素已访问过.
- 递推工作：
  1. 标记当前单元格，将索引$(i,j)$存入集合$visited$中，代表此单元格已被访问过；
  2. 搜索下一个单元格：计算当前元素的下、右两方向元素数位和，开启下层递归；
  3. 回溯返回值：返回“1+右方搜索的可达解总数+下方搜索的可达解总数”，代表从本单元格递归搜索的可达解总数.

#### Code

```python
def movingCount(m: int, n: int, k: int) -> int:
    # 深度优先遍历: 通过递归，先朝一个方向搜到底，再回溯到上一个节点，沿一个方向搜索，以此类推.
    # 剪枝：在搜索中，遇到数位和超过目标值，此元素已访问，则立即返回，称为可行性剪枝.
    def dfs(i, j, si, sj):
        if i >= m or j >= n or k < si + sj or (i, j) in visited: return 0
        visited.add((i, j))
        return 1 + dfs(i + 1, j, si + 1 if (i + 1) % 10 else si - 8, sj) + dfs(i, j + 1, si,
                                                                               sj + 1 if (j + 1) % 10 else sj - 8)

    visited = set()
    return dfs(0, 0, 0, 0)
```

### 法二：广度优先遍历BFS

利用队列，按照“平推”方式向前搜索.

- 初始化：将机器人初始点$(0,0)$加入队列$queue$;
- 迭代终止条件：$queue$为空，代表已遍历完所有可达解；
- 迭代工作：
  1. 单元格出队；将队首单元格索引、数位和弹出，作为当前搜索单元格；
  2. 判断是否跳过：行列索引越界；数位和超过目标值k; 当前元素已访问过，continue.
  3. 标记当前单元格：将单元格索引$(i,j)$存入集合$visited$中，代表此单元格已被访问过.
  4. 单元格出队：将当前元素下方、右方的单元格索引、数位和加入$queue$.

- 返回值：$len(visited)$, 即可达解数量.

#### Code

```python
def movingCount2(m, n, k):
    # 广度优先搜索：利用队列, 按照“平推”方式向前搜素.
    queue, visited2 = [(0, 0, 0, 0)], set()
    while queue:
        i, j, si, sj = queue.pop(0)
        if i >= m or j >= n or k < si + sj or (i, j) in visited2: continue
        visited2.add((i, j))
        queue.append((i + 1, j, si + 1 if (i + 1) % 10 else si - 8, sj))
        queue.append((i, j + 1, si, sj + 1 if (j + 1) % 10 else sj -8))
    return len(visited2)
```

## 例2 矩阵中的路径

[剑指 Offer 12](https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/)

```python
给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
示例 1：

输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
示例 2：

输入：board = [["a","b"],["c","d"]], word = "abcd"
输出：false
```

典型的矩阵搜索问题：**深度优先搜索+剪枝**

- DFS：暴力法遍历矩阵中所有字符串可能性. 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推；
- 剪枝：搜索中，遇到这条路不可能和目标字符串匹配成功(元素不同、已被访问)，则应立即返回.

### 算法流程

1. 递归参数：当前元素在矩阵$board$中的行列索引$i,j$，当前目标字符在$word$中索引$k$.
2. 终止条件：
   - 返回$False$：(1) 行或列索引越界；(2) 当前矩阵元素与目标字符不同；(3) 当前矩阵元素已访问过
   - 返回$True$：$k=len(board)-1$，即字符串已完成匹配.
3. 递推工作：
   - 标记当前元素，将$board[i][j]$储存在临时变量$tmp$，将$board[i][j]$修改为空字符，代表此元素已访问过，防止之后搜索时重复访问；
   - 搜索下一单元格：朝当前元素 上、下、左、右四个方向开启下层递归，使用“或”连接（只需找到一条可行路径就直接返回，不再做后续DFS），记录结果至$res$.
   - 还原当前矩阵元素,即$board[i][j]=tmp$
4. 返回布尔量$res$，代表是否搜索到目标字符串.

### Code

```python
def exist(board, word):
    def dfs(i, j, k):
        if not 0 <= i < len(board) or not 0 <= j < len(board[0]) or board[i][j] != word[k]: return False
        if k == len(word) - 1:
            return True
        p = board[i][j]
        board[i][j] = ''
        res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k +1) or dfs(i, j - 1, k + 1)
        board[i][j] = p
        return res
    for i in range(len(board)):
        for j in range(len(board[0])):
            if dfs(i, j, 0):
                return True
    return False
board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]]
word = "ABCCED"
print(exist(board, word))
```

### 复杂度分析

- 时间复杂度$O(3^k mn)$

最差情况下，需要遍历矩阵中长度为k字符串所有方案（方案数计算：设字符串长度为k，搜索中舍弃回头方向，剩下3种选择，因此$O(3^k)$）

- 空间复杂度$O(k)$

递归深度不超过$k$，系统因函数调用累计使用栈空间$O(k)$.

![提交记录](https://s2.loli.net/2022/06/13/ONyT4mzP7MQqeux.png)

## 例3 岛屿最大面积

```python
给你一个大小为 m x n 的二进制矩阵 grid 。

岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。

岛屿的面积是岛上值为 1 的单元格的数目。

计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。

示例1：
输入：grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
输出：6
解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。

示例 2：

输入：grid = [[0,0,0,0,0,0,0,0]]
输出：0
```

![示例1](https://s2.loli.net/2022/06/13/FGEYKxyekvz5t74.png)

### 算法流程

1. 递归参数：当前元素在矩阵$grid$中的行列索引$i,j$；
2. 终止条件：直接返回0，(1) 行或列索引越界；(2) 当前矩阵元素为0；(3) 当前矩阵元素已访问过
3. 递归工作：以陆地为中心向四周找，若为陆地(数字1),开启递归，朝当前元素 上、下、左、右四个方向开启下层递归，记录所得结果.
4. 以变量$maxArea$在遍历整个矩阵过程中更新最大面积，最终返回$maxArea$即为所求.

### Code

```python
def maxAreaOdIsland(grid):
    if not grid or len(grid[0]) == 0: return 0
    # 向四周寻找陆地
    def dfs(i, j):
        # 递归终止
        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0:
            return 0
        grid[i][j] = 0  # 避免重复访问

        up = dfs(i - 1, j)
        down = dfs(i + 1, j)
        left = dfs(i, j - 1)
        right = dfs(i, j + 1)
        return up + down + left + right + 1
    maxArea = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 1:
                curArea = dfs(i, j)
                maxArea = max(maxArea, curArea)
    return maxArea

grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
print(maxAreaOdIsland(grid))
```

## 例4 岛屿数量

[200. 岛屿数量 ](https://leetcode.cn/problems/number-of-islands/)

```python
给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

示例 1：

输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
示例 2：

输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

```python
def numIslands(grid):
    if not grid or len(grid) == 0:
        return 0
    # 寻找以(i,j)为中心的岛屿的边界，dfs目标是为了修改标记位为0，无需返回值
    def dfs(i, j):
        #  递归终止条件：越界或遇到水域
        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0':
            return
        grid[i][j] = '0'  # 把当前位置标记为0，避免重复访问

        # 搜索上下左右
        dfs(i - 1, j)
        dfs(i + 1, j)
        dfs(i, j - 1)
        dfs(i, j + 1)
    res = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == '1':  # 遇到陆地开启dfs，水域直接跳过
                dfs(i, j)

                # dfs返回说明已经找到一块岛屿的边界了（数组边界或水域）
                res += 1
    return res
```

## 例5 求1+2+...+n

```python
求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句。

示例 1：

输入: n = 3
输出: 6
示例 2：

输入: n = 9
输出: 45
```

### 逻辑运算符的短路效应

| $if(A\&\& B)$ | 若A为False，则B的判断不会执行（短路），$A\&\& B$为False. |
| :-----------: | :------------------------------------------------------: |
|  $if(A||B)$   |   若A为True，则B的判断不会执行（短路），$A||B$为True.    |

本题需要实现“当$n=1$时终止递归”的需求，可通过短路实现，
$$
n > 1 \quad \&\& \quad sunNums(n-1)
$$

```python
class Solution:
    def __init__(self):
        self.res = 0
    def sumNums(self, n: int) -> int:
        n > 1 and self.sumNums(n-1)
        self.res += n
        return self.res
```

## 例6 字符串的排列

```python
输入一个字符串，打印出该字符串中字符的所有排列。

可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

示例:

输入：s = "abc"
输出：["abc","acb","bac","bca","cab","cba"]
```

- 考虑深度优先搜索，通过字符交换，先固定第1位字符，再固定第2位字符，...,最后固定第n位字符;
- 剪枝：在固定某字符时，保证“每种字符只在此位固定一次”，即遇到重复字符时不交换，直接跳过.

### 递归过程

1. 终止条件：当$x=len(c)-1$时，代表所有位已固定，将当前组合c转化为字符串加入$res$，并返回
2. 递推参数：当前固定位$x$
3. 递推工作：初始化集合$set$，用于排除重复字符；将第$x$位字符与$i\in[x,len(c)]$字符分别交换，进入下层递归
   - 剪枝：若$c[i]$在$set$中，代表重复字符，“剪枝”；
   - $c[i]$加入$set$,以便之后遇到重复字符时剪枝；
   - 固定字符：将$c[i],c[x]$交换，即固定$c[i]$为当前字符；
   - 开启下层递归：调用$dfs(x+1)$，开始固定第$x+1$个字符；
   - 还原交换：将$c[i],c[x]$交换，还原回来.

### Code

```python
def permutation(self, s: str) -> List[str]:
        c, res = list(s), []
        def dfs(x):
            if x == len(c) - 1:
                res.append(''.join(c))
                return
            dic = set()
            for i in range(x, len(c)):
                if c[i] in dic: continue
                dic.add(c[i])
                c[i], c[x] = c[x], c[i]
                dfs(x + 1)
                c[i], c[x] = c[x], c[i]
        dfs(0)
        return res
```

### 复杂度分析

- 时间复杂度$O(n!n)$

$n$为字符串长度，方案数$n!$,即复杂度$O(n!)$；拼接操作$join()$的复杂度$O(n)$

- 空间复杂度$O(n^2)$

全排列递归深度$n$, 系统累计使用栈空间$O(n)$; 辅助集合$set$累计存储字符最多为$n+(n-1)+...+1=\frac{n(n-1)}{2}$, 占用$O(n^2)$额外空间.